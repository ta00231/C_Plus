# 数组

1. 数组是存放在连续内存空间上的相同类型数据的集合。

   ![image-20230306203513520](C:\Users\Not a Literary Gaint\AppData\Roaming\Typora\typora-user-images\image-20230306203513520.png)

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

正是**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

## 二分查找

[LeetCode题目链接](https://leetcode.cn/problems/binary-search/)

**数组为有序数组**，同时题目还强调**数组中无重复元素**。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

![image-20230306231143466](C:\Users\Not a Literary Gaint\AppData\Roaming\Typora\typora-user-images\image-20230306231143466.png)

```go
// 写法一 [left, right]
func search(nums []int, target int) int {
    right := len(nums) - 1
    left := 0
    for left <= right {
        mid := left + (right - left)/2
        if target == nums[mid] {
            return mid
        } else if target < nums[mid] {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return -1
}
```

![image-20230306231157906](C:\Users\Not a Literary Gaint\AppData\Roaming\Typora\typora-user-images\image-20230306231157906.png)

```go
// 写法二 [left, right)
func search(nums []int, target int) int {
    right := len(nums)
    left := 0
    for left < right {
        mid := left + (right - left) / 2
        if target == nums[mid] {
            return mid
        } else if target < nums[mid] {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return -1
}
```

## 移除元素

[leetcode题目链接](https://leetcode.cn/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

**双指针法**，**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

```go
func removeElement(nums []int, val int) int {
    slowIndex := 0
    for _, v := range nums {
        if v != val {
            nums[slowIndex]=v
            slowIndex++
        }  
    }
    return slowIndex
}
```

## 有序数组的平方

[leetcode题目链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

**双指针法**，**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

```go
func sortedSquares(nums []int) []int {
	n := len(nums)
	result := make([]int, n)
	index, right, left := n-1, n-1, 0
	for right >= left {
		rm, lm := nums[right]*nums[right], nums[left]*nums[left]
		if rm > lm {
			result[index] = rm
			right--
		} else {
			result[index] = lm
			left++
		}
		index--
	}
	return result
}
```

## 长度最小的子数组

[leetcode题目链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

**滑动窗口**，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。**

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

```go
func minSubArrayLen(target int, nums []int) []int {
	result, subL, sum, j := math.MaxInt32, 0, 0, 0
	for i, v := range nums {
		sum += v
		for sum >= target {
			subL = i - j + 1
			if result > subL {
				result = subL
			}
			sum -= nums[j]
			j++
		}
	}
	if result == math.MaxInt32 {
		return 0
	} else {
		return result
	}
}
```

