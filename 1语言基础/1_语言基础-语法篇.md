# 语法篇

## 1. 第一个程序

```c++
#include <iostream>
using namespace std;
 
// main() 是程序开始执行的地方
 
int main()
{
   cout << "Hello World"; // 输出 Hello World
   return 0;
}
```

- C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **<iostream>**。
- 下一行 **using namespace std;** 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。
- 下一行 **// main() 是程序开始执行的地方** 是一个单行注释。单行注释以 // 开头，在行末结束。
- 下一行 **int main()** 是主函数，程序从这里开始执行。
- 下一行 **cout << "Hello World";** 会在屏幕上显示消息 "Hello World"。
- 下一行 **return 0;** 终止 main( )函数，并向调用进程返回值 0。
- 一行就是一个语句，每个语句需要以**；**结尾，**{}**包裹的表示一个语句块。

## 2. 注释

C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略（即执行时无影响）。

C++ 注释一般有两种：

- **//** - 一般用于单行注释，以 **//** 开始，直到行末为止。

```C++
#include <iostream>
using namespace std;
 
int main() {
  // 这是一个注释
  cout << "Hello World!";
  return 0;
}
```

- /*** ... \*/** - 一般用于多行注释，注释以 **//** 开始，直到行末为止。

```c++
#include <iostream>
using namespace std;
 
int main() {
    /* 这是注释 */
 
    /* C++ 注释也可以
     * 跨行
     */ 
    cout << "Hello World!";
    return 0;
}
```

## 3.数据类型

### 1） 7种基本类型

|   类型   | 关键字  |
| :------: | :-----: |
|  布尔型  |  bool   |
|  字符型  |  char   |
|   整型   |   int   |
|  浮点型  |  float  |
| 双浮点型 | double  |
|  无类型  |  void   |
| 宽字符型 | wchar_t |

```c++
// wchar_t 实际定义
typedef short int wchar_t;
```

所以 **wchar_t** 实际上的空间是和 **short int** 一样。

一些基本类型可以使用一个或多个类型修饰符进行修饰：

- **signed**
- **unsigned**
- **short**
- **long**

下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。

|        类型        |      位       |                             范围                             |
| :----------------: | :-----------: | :----------------------------------------------------------: |
|        bool        |    1个字节    |                              无                              |
|        char        |   1 个字节    |                  -128 到 127 或者 0 到 255                   |
|   unsigned char    |   1 个字节    |                           0 到 255                           |
|    signed char     |   1 个字节    |                         -128 到 127                          |
|        int         |   4 个字节    |                  -2147483648 到 2147483647                   |
|    unsigned int    |   4 个字节    |                       0 到 4294967295                        |
|     signed int     |   4 个字节    |                  -2147483648 到 2147483647                   |
|     short int      |   2 个字节    |                       -32768 到 32767                        |
| unsigned short int |   2 个字节    |                         0 到 65,535                          |
|  signed short int  |   2 个字节    |                       -32768 到 32767                        |
|      long int      |   8 个字节    |   -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807    |
|  signed long int   |   8 个字节    |   -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807    |
| unsigned long int  |   8 个字节    |               0 到 18,446,744,073,709,551,615                |
|       float        |   4 个字节    | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
|       double       |   8 个字节    | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
|    long double     |   16 个字节   | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
|      wchar_t       | 2 或 4 个字节 |                          1 个宽字符                          |



**注意：**默认情况下，int、short、long都是带符号的，即 signed。long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。

### 2）枚举类型

枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。

如果一个变量只有**几种可能的值**，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。创建枚举，需要使用关键字 **enum**。

```c++
/*
*enum 枚举名{ 
*     标识符[=整型常数], 
*     标识符[=整型常数], 
*... 
*    标识符[=整型常数]
*} 枚举变量;
*/

enum color1 { red, green, blue } c; // 此时 c 为 red， 值为0.
c = blue; // 此时 c 为 blue， 值为2.

// 在这里，blue 的值为 6，默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。
enum color2 { red, green=5, blue }; 
```

如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。

默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。

### 3）typedef 声明

您可以使用 **typedef** 为一个已有的类型取一个新的名字。

```c++
// typedef type newname; 
typedef int feet; // 语句会告诉编译器，feet 是 int 的另一个名称
feet distance; // 声明是完全合法的，它创建了一个整型变量 distance
```

### 4）类型转换

将一个数据类型的值转换为另一种数据类型的值。

四种类型转换：静态转换、动态转换、常量转换和重新解释转换。

- ### 静态转换（Static Cast）

  ```c++
  /*
      静态转换是值的强制转换。
  
      通常用于类型相似的转换，例如将 int 转换为 float 。
  
      不进行任何运行时类型检查，因此可能会导致运行时错误。
  */
  int i = 10;
  float f = static_cast<float>(i); // 静态将int类型转换为float类型
  ```

- ### 动态转换（Dynamic Cast）

  ```c++
  /*
  	动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。
  	在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。
  */
  class Base {};
  class Derived : public Base {};
  Base* ptr_base = new Derived;
  Derived* ptr_derived = dynamic_cast<Derived*>(ptr_base); // 将基类指针转换为派生类指针
  ```

  

- ### 常量转换（Const Cast）

  ```c++
  /*
  	常量转换用于将 const 类型的对象转换为非 const 类型的对象。
  
  	只能用于转换掉 const 属性，不能改变对象的类型。
  */
  const int i = 10;
  int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
  ```

  

- ### 重新解释转换（Reinterpret Cast）

  ```c++
  /*
      重新解释转换是值的重新解释，通常用于在不同的数据类型之间进行转换。
  
      不进行任何类型检查，因此可能会导致未定义的行为。
  */
  int i = 10;
  float f = reinterpret_cast<float&>(i); // 重新解释将int类型转换为float类型
  ```

## 4. 变量

![img](https://www.runoob.com/wp-content/uploads/2015/01/cpp-variable-types-2020-12-14.png)

变量其实只不过是程序可操作的存储区的名称。

可以由字母、数字和下划线字符组成，必须以字母或下划线开头。

大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。

#### 数据类型结合

1. 整数类型（Integer Types）：
   - `int`：用于表示整数，通常占用4个字节。
   - `short`：用于表示短整数，通常占用2个字节。
   - `long`：用于表示长整数，通常占用4个字节。
   - `long long`：用于表示更长的整数，通常占用8个字节。
2. 浮点类型（Floating-Point Types）：
   - `float`：用于表示单精度浮点数，通常占用4个字节。
   - `double`：用于表示双精度浮点数，通常占用8个字节。
   - `long double`：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。
3. 字符类型（Character Types）：
   - `char`：用于表示字符，通常占用1个字节。
   - `wchar_t`：用于表示宽字符，通常占用2或4个字节。
   - `char16_t`：用于表示16位Unicode字符，占用2个字节。
   - `char32_t`：用于表示32位Unicode字符，占用4个字节。
4. 布尔类型（Boolean Type）：
   - `bool`：用于表示布尔值，只能取`true`或`false`。
5. 枚举类型（Enumeration Types）：
   - `enum`：用于定义一组命名的整数常量。
6. **指针类型（Pointer Types）：**
   - **`type*`：用于表示指向类型为`type`的对象的指针。**
7. **数组类型（Array Types）：**
   - **`type[]`或`type[size]`：用于表示具有相同类型的元素组成的数组。**
8. **结构体类型（Structure Types）：**
   - **`struct`：用于定义包含多个不同类型成员的结构。**
9. **类类型（Class Types）：**
   - **`class`：用于定义具有属性和方法的自定义类型。**
10. **共用体类型（Union Types）：**
    - **`union`：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。**

### 1）变量定义

```c++
// type variable_name = value;
int d = 3, f = 5;           // 定义并初始化 d 和 f
char x = 'x';               // 变量 x 的值为 'x'
```

### 2）变量声明

变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节也能继续进一步的编译。

您可以使用 **extern** 关键字在任何地方声明一个变量。

虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。

```c++
#include <iostream>
using namespace std;
 
// 变量声明
extern int a, b;
extern int c;
extern float f;
  
int main ()
{
  // 变量定义
  int a, b;
  int c;
  float f;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c << endl ;
 
  f = 70.0/3.0;
  cout << f << endl ;
 
  return 0;
}
```

### 3）左值与右值

- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

## 5.变量作用域

一般来说有三个地方可以定义变量：

- 在函数或一个代码块内部声明的变量，称为**局部变量**。

- 在函数参数的定义中声明的变量，称为**形式参数**。

- 在所有函数外部声明的变量，称为**全局变量**。

  ```c++
  #include <iostream>
  using namespace std;
   
  // 全局变量声明
  int g;
   
  int main ()
  {
    // 局部变量声明
    int a, b;
   
    // 实际初始化
    a = 10;
    b = 20;
    g = a + b;
   
    cout << g;
   
    return 0;
  }
  ```

作用域是程序的一个区域，变量的作用域可以分为以下几种：

- **局部作用域**：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在**函数执行完后**被销毁。

- **全局作用域**：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序**结束时**被销毁。

- **块作用域**：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在**代码块执行完后**被销毁。

- **类作用域**：在**类内部**声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。

  ```c++
  #include <iostream>
  
  class MyClass {
  public:
      static int class_var;  // 类作用域变量
  };
  
  int MyClass::class_var = 30;
  
  int main() {
      std::cout << "类变量: " << MyClass::class_var << std::endl;
      return 0;
  }
  /*
  	MyClass 类中声明了一个名为 class_var 的类作用域变量。
  	可以使用类名和作用域解析运算符 :: 来访问这个变量，在 main 中输出得到 “类变量：30“。
  */
  ```

**注意：**

- 如果在内部作用域中声明的变量与外部作用域中的变量同名，则**内部作用域中的变量将覆盖外部作用域**中的变量。

  ```c++
  #include <iostream>
  
  int main() {
      int a = 10;
      {
          int a = 20;  // 块作用域变量
          std::cout << "块变量: " << a << std::endl;
      }
      std::cout << "外部变量: " << a << std::endl;
      return 0;
  }
  /* 
  	结果
  	块变量: 20
  	外部变量: 10
  */
  ```

- 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。

- 定义全局变量时，系统会自动初始化为下列值：

  | 数据类型 | 初始化默认值 |
  | :------: | :----------: |
  |   int    |      0       |
  |   char   |     '\0'     |
  |  float   |      0       |
  |  double  |      0       |
  | pointer  |     NULL     |

## 6.常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。

常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

### 定义常量

在 C++ 中，有两种简单的定义常量的方式，一般常量变量名为**大写字母**：

- 使用 **#define** 预处理器。

  ```c++
  // #define identifier value
  #include <iostream>
  using namespace std;
   
  #define LENGTH 10   
  #define WIDTH  5
  #define NEWLINE '\n'
   
  int main()
  {
   
     int area;  
     
     area = LENGTH * WIDTH;
     cout << area;  // 50
     cout << NEWLINE;  // 换行
     return 0;
  }
  ```

- 使用 **const** 关键字。

  ```c++
  // const type variable = value;
  #include <iostream>
  using namespace std;
   
  int main()
  {
     const int  LENGTH = 10;
     const int  WIDTH  = 5;
     const char NEWLINE = '\n';
     int area;  
     
     area = LENGTH * WIDTH;
     cout << area;  // 50
     cout << NEWLINE;  // 换行
     return 0;
  }
  ```

## 7.部分存储类

存储类定义 C++ 程序中变量/函数的**范围（可见性）和生命周期**。这些说明符放置在它们所修饰的类型之前。

### 1）static 存储类

- 作用于局部变量，则该变量**只初始化一次**，值保留至程序结束；

- 作用于全局变量，会使变量的作用域限制在**声明它的文件内**；

- 作用于类数据成员，会导致仅有一个该成员的副本被类的**所有对象**共享。

  ```c++
  #include <iostream>
   
  // 函数声明 
  void func(void);
   
  static int count = 10; /* 全局变量 */
   
  int main()
  {
      while(count--)
      {
         func();
      }
      return 0;
  }
  // 函数定义
  void func( void )
  {
      static int i = 5; // 局部静态变量
      i++;
      std::cout << "变量 i 为 " << i ;
      std::cout << " , 变量 count 为 " << count << std::endl;
  }
  ```

  ```
  变量 i 为 6 , 变量 count 为 9
  变量 i 为 7 , 变量 count 为 8
  变量 i 为 8 , 变量 count 为 7
  变量 i 为 9 , 变量 count 为 6
  变量 i 为 10 , 变量 count 为 5
  变量 i 为 11 , 变量 count 为 4
  变量 i 为 12 , 变量 count 为 3
  变量 i 为 13 , 变量 count 为 2
  变量 i 为 14 , 变量 count 为 1
  变量 i 为 15 , 变量 count 为 0
  ```

### 2）extern 存储类

提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。

- 可用于提前声明；
- 使用 *extern* 来得到其他文件内已定义的变量或函数的引用。

```c++
// main.cpp
#include <iostream>
 
int count ;
// 取用
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}
```

```c++
// support.cpp
#include <iostream>

extern int count;
 
void write_extern(void)
{
   std::cout << "Count is " << count << std::endl;
}
```

```
Count is 5
```

### 3）thread_local 存储类

- 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。
- thread_local 说明符可以与 static 或 extern 合并。
- thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。

## 8.运算符

- 算术运算符

  | 运算符 |               描述               |       实例       |
  | :----: | :------------------------------: | :--------------: |
  |   +    |         把两个操作数相加         | A + B 将得到 30  |
  |   -    | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |
  |   *    |         把两个操作数相乘         | A * B 将得到 200 |
  |   /    |           分子除以分母           |  B / A 将得到 2  |
  |   %    |     取模运算符，整除后的余数     |  B % A 将得到 0  |
  |   ++   |     自增运算符，整数值增加 1     |  A++ 将得到 11   |
  |   --   |     自减运算符，整数值减少 1     |   A-- 将得到 9   |

- 关系运算符

  | 运算符 | 描述                                                         | 实例              |
  | :----: | ------------------------------------------------------------ | :---------------- |
  |   ==   | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |
  |   !=   | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |
  |   >    | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |
  |   <    | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |
  |   >=   | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
  |   <=   | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |

- 逻辑运算符

  | 运算符 | 描述                                                         | 实例                 |
  | :----: | ------------------------------------------------------------ | :------------------- |
  |   &&   | 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。     | (A && B) 为 false。  |
  |  \|\|  | 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 | (A \|\| B) 为 true。 |
  |   !    | 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 | !(A && B) 为 true。  |

- 位运算符

  | 运算符 | 描述                                                         | 实例                                                         |
  | :----: | :----------------------------------------------------------- | :----------------------------------------------------------- |
  |   &    | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
  |   \|   | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
  |   ^    | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
  |   ~    | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
  |   <<   | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
  |   >>   | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

- 赋值运算符

  | 运算符 | 描述                                                         | 实例                            |
  | :----: | ------------------------------------------------------------ | ------------------------------- |
  |   =    | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
  |   +=   | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
  |   -=   | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
  |   *=   | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
  |   /=   | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
  |   %=   | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
  |  <<=   | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
  |  >>=   | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
  |   &=   | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
  |   ^=   | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
  |  \|=   | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |

- 杂项运算符

  | 运算符               | 描述                                                         |
  | -------------------- | ------------------------------------------------------------ |
  | sizeof               | [sizeof 运算符](https://www.runoob.com/cplusplus/cpp-sizeof-operator.html)返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |
  | Condition ? X : Y    | [条件运算符](https://www.runoob.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 |
  | ,                    | [逗号运算符](https://www.runoob.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |
  | .（点）和 ->（箭头） | [成员运算符](https://www.runoob.com/cplusplus/cpp-member-operators.html)用于引用类、结构和共用体的成员。 |
  | Cast                 | [强制转换运算符](https://www.runoob.com/cplusplus/cpp-casting-operators.html)把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |
  | &                    | [指针运算符 &](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 返回变量的地址。例如 &a; 将给出变量的实际地址。 |
  | *                    | [指针运算符 *](https://www.runoob.com/cplusplus/cpp-pointer-operators.html) 指向一个变量。例如，*var; 将指向变量 var。 |

### 运算符优先级

|    类别    |              运算符               |  结合性  |
| :--------: | :-------------------------------: | :------: |
|    后缀    |         () [] -> . ++ - -         | 从左到右 |
|    一元    |  + - ! ~ ++ - - (type)* & sizeof  | 从右到左 |
|    乘除    |               * / %               | 从左到右 |
|    加减    |                + -                | 从左到右 |
|    移位    |               << >>               | 从左到右 |
|    关系    |             < <= > >=             | 从左到右 |
|    相等    |               == !=               | 从左到右 |
|  位与 AND  |                 &                 | 从左到右 |
| 位异或 XOR |                 ^                 | 从左到右 |
|  位或 OR   |                \|                 | 从左到右 |
| 逻辑与 AND |                &&                 | 从左到右 |
| 逻辑或 OR  |               \|\|                | 从左到右 |
|    条件    |                ?:                 | 从右到左 |
|    赋值    | = += -= *= /= %=>>= <<= &= ^= \|= | 从右到左 |
|    逗号    |                 ,                 | 从左到右 |

## 9.循环

![循环结构](https://www.runoob.com/wp-content/uploads/2015/12/loop.png)

### 1）循环类型

| 循环类型                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [while 循环](https://www.runoob.com/cplusplus/cpp-while-loop.html) | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |
| [for 循环](https://www.runoob.com/cplusplus/cpp-for-loop.html) | 多次执行一个语句序列，简化管理循环变量的代码。               |
| [do...while 循环](https://www.runoob.com/cplusplus/cpp-do-while-loop.html) | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。    |
| [嵌套循环](https://www.runoob.com/cplusplus/cpp-nested-loops.html) | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |

### 2）循环控制语句

| 控制语句                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [break 语句](https://www.runoob.com/cplusplus/cpp-break-statement.html) | 终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 |
| [continue 语句](https://www.runoob.com/cplusplus/cpp-continue-statement.html) | 引起循环跳过主体的剩余部分，立即重新开始测试条件。           |
| [goto 语句](https://www.runoob.com/cplusplus/cpp-goto-statement.html) | 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 |

### 3）无限循环

如果条件永远不为假，则循环将变成无限循环。

```c++
// for 无限循环
for( ; ; )
{
	...
}

// while 无限循环
while(1)
{
	...
}
```

## 10.判断

![C++ 中的判断语句](https://www.runoob.com/wp-content/uploads/2015/12/if.png)

| 语句                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [if 语句](https://www.runoob.com/cplusplus/cpp-if.html)      | 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。    |
| [if...else 语句](https://www.runoob.com/cplusplus/cpp-if-else.html) | 一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。 |
| [嵌套 if 语句](https://www.runoob.com/cplusplus/cpp-nested-if.html) | 您可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。 |
| [switch 语句](https://www.runoob.com/cplusplus/cpp-switch.html) | 一个 **switch** 语句允许测试一个变量等于多个值时的情况。     |
| [嵌套 switch 语句](https://www.runoob.com/cplusplus/cpp-nested-switch.html) | 您可以在一个 **switch** 语句内使用另一个 **switch** 语句。   |

### ? : 运算符

? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。

```c++
// Exp1 ? Exp2 : Exp3;
#include <iostream>
using namespace std;
 
int main ()
{
   // 局部变量声明
   int x, y = 10;
 
   x = (y < 10) ? 30 : 40;
 
   cout << "value of x: " << x << endl;
 
   return 0;
}
// value of x: 40
```

## 11.函数

函数是**一组一起执行一个任务的语句**。

每个 C++ 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

### 1）定义函数

- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。

```c++
/*
	return_type function_name( parameter list )
    {
       body of the function
    }
*/
// 两数比较取其大
int max(int num1, int num2)
{
    int result;
    
    if (num1 > num2)
    {
        result = num1;
    }else
    {
        result = num2;
    }
    
    return result;
}
```

### 2)  函数声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

```c++
// return_type function_name( parameter list );
```

在函数声明中，参数的名称并不重要，只有参数的类型是必需的：

```c++
int max(int, int);
```

### 3）调用函数

当程序调用函数时，程序控制权会转移给被调用的函数，直至被调用函数执行完毕或异常结束。

调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。

```c++
#include <iostream>
using namespace std;
 
// 函数声明
int max(int num1, int num2);
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
   int ret;
 
   // 调用函数来获取最大值
   ret = max(a, b);
 
   cout << "Max value is : " << ret << endl;
 
   return 0;
}
 
// 函数返回两个数中较大的那个数
int max(int num1, int num2) 
{
   // 局部变量声明
   int result;
 
   if (num1 > num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
```

```
Max value is : 200
```

### 4）函数参数

如果函数要使用参数，则必须声明接受参数值的变量：**形式参数**。

形式参数就像局部变量，在进入函数时被创建，退出时被销毁。

当调用函数时，有三种向函数传递参数的方式：

| 调用类型 |                             描述                             |
| :------: | :----------------------------------------------------------: |
| 传值调用 | 把参数的实际值赋值给函数的形式参数。<br />修改形式参数对实际参数没有影响。 |
| 指针调用 | 把参数的地址赋值给形式参数。<br />地址用于访问调用中要用到的实际参数，修改形式参数**会影响**实际参数。 |
| 引用调用 | 把参数的引用赋值给形式参数。<br />引用用于访问调用中要用到的实际参数，修改形式参数**会影响**实际参数。 |

```c++
#include <iostream>
using namespace std;
 
// 函数声明（形式参数）
void swap(int, int);
// 函数声明（指针参数）
void swap(int *, int *);
// 函数声明（引用参数）
void swap_d(int &, int &);
 
int main ()
{
   // 局部变量声明
    int a1 = 100;
    int b1 = 200;
    cout << "交换前，a1 的值：" << a1 << endl;
    cout << "交换前，b1 的值：" << b1 << endl;
    // 调用函数来交换值(形式参数)
    swap(a1, b1);
    cout << "交换后，a1 的值：" << a1 << endl;
    cout << "交换后，b1 的值：" << b1 << endl;

    int a2 = 100;
    int b2 = 200;
    cout << "交换前，a2 的值：" << a2 << endl;
    cout << "交换前，b2 的值：" << b2 << endl;
    // 调用函数来交换值(指针参数)
    swap(&a2, &b2);
    cout << "交换后，a2 的值：" << a2 << endl;
    cout << "交换后，b2 的值：" << b2 << endl;

    int a3 = 100;
    int b3 = 200;
    cout << "交换前，a3 的值：" << a3 << endl;
    cout << "交换前，b3 的值：" << b3 << endl;
    // 调用函数来交换值(引用参数)
    swap_d(a3, b3);
    cout << "交换后，a3 的值：" << a3 << endl;
    cout << "交换后，b3 的值：" << b3 << endl;
 
   return 0;
}

// 函数定义（形式参数）
void swap(int x, int y)
{
    int temp = x;
    x = y;
    y = temp;
    return;
}
// 函数定义（指针参数）
void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
    return;
}
// 函数定义（引用参数）
void swap_d(int &x, int &y)
{
    int temp = x;
    x = y;
    y = temp;
    return;
}

// 利用异或优化swap
int swap_xor(int &x, int&y)
{
    // 简单写法： x ^= y ^= x ^= y;
    int temp = x ^ y;
    int x = temp ^ x;
    int y = temp ^ y;
    return;
}
```

### 5）参数的默认值

当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。

```c++
#include <iostream>
using namespace std;
 
int sum(int a, int b=20)
{
  int result;
 
  result = a + b;
  
  return (result);
}
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
   int result;
 
   // 调用函数来添加值
   result = sum(a, b);
   cout << "Total value is :" << result << endl;
 
   // 再次调用函数
   result = sum(a);
   cout << "Total value is :" << result << endl;
 
   return 0;
}
```

```
Total value is :300
Total value is :120
```

### 6）Lambda 函数与表达式

Lambda 表达式把函数看作对象，匿名函数。

Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。

```c++
// [capture](parameters)->return-type{body}
[](int x, int y) -> int { int z = x + y; return z + x; }
// 自动推断返回类型
[](int x, int y){ return x < y ; }
[]{ ++global_x; } 
```

需要指定捕获模式"[]"，

```
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

```c++
// 定义简单的lambda表达式
auto basicLambda = [] { cout << "Hello, world!" << endl; };

// 调用
basicLambda();
// 输出：Hello, world!

// 指明返回类型
auto add = [](int a, int b) -> int { return a + b; };

// 自动推断返回类型
auto multiply = [](int a, int b) { return a * b; };
int sum = add(2, 5);   // 输出：7
int product = multiply(2, 5);  // 输出：10
```

## 12.随机数生成

关于随机数生成器，有两个相关的函数: **rand()**，**srand()** 。

 **srand(1):** 直接使用 1 来初始化种子。

不过为了防止随机数每次重复，常常使用系统时间来初始化，即使用 **time()** 来获得系统时间，它的返回值为从 00:00:00 GMT, January 1, 1970 到现在所持续的秒数，然后将 time_t 型数据转化为(unsigned)型再传给 srand 函数，即： **srand((unsigned) time(&t))**; 还有一个经常用法，不需要定义time_t型t变量,即： **srand((unsigned) time(NULL))**; 直接传入一个空指针，因为你的程序中往往并不需要经过参数获得的t数据。

```c++
/*
    1、rand 随机数产生的范围：在标准的 C 库中函数 rand() 可以生成 0~RAND_MAX 之间的一个随机数，其中 RAND_MAX 是 stdlib.h 中定义的一个整数，它与系统有关，至少为 32767。

    2、使用 rand() 和 srand() 产生指定范围内的随机整数的方法：“模除+加法”的方法。如要产生 [m,n] 范围内的随机数 num，可用：int num=rand()%(n-m+1)+m;（即 rand()%[区间内数的个数]+[区间起点值]）
*/

#include <iostream>
#include<stdio.h>
#include<time.h>
#define random(x, y)(rand()%(y-x+1)+y)
using namespace std;

int main()
{
    srand((unsigned)time(NULL));//部署随机种子
    for (int i = 0; i < 10; i++){
        cout << random(0, 100) << endl;
        //输出0-100的随机数
    };
    return 0;
}
```

### 真随机建议选用 random 库

建议原因：[rand | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/c-runtime-library/reference/rand?view=msvc-170)

```c++
#include <random>
#include <iostream>

using namespace std;

int main()
{
    // 如果可用的话，从一个随机数发生器上获得一个真正的随机数
    random_device rd;   
    // gen是一个使用rd()作种子初始化的标准梅森旋转算法的随机数发生器
    mt19937 gen(rd());  

    for (int i = 0; i < 5; ++i) {
        cout << gen() << " "; // print the raw output of the generator.
    }
    cout << endl;
}
```

```
2430338871 3531691818 2723770500 3252414483 3632920437
```

指定范围内的随机数

```c++
#include <random>
#include <iostream>

using namespace std;

int main()
{
    random_device rd;  
    mt19937 gen(rd()); 
    uniform_int_distribution<> dist(1,6); // 1-6 之间的整型均匀分布

    for (int i = 0; i < 5; ++i) {
        cout << dist(gen) << " "; // 将gen生成的随机整数转换到分布上.
    }
    cout << endl;
}
```

```
5 1 6 1 2
```

## 13.数组

*它可以存储一个固定大小的相同类型元素的顺序集合*

1）声明数组

声明一个数组，需要指定元素的类型和元素的数量

```c++
// type arrayName [ arraySize ];
double balance[10];
```

2）初始化

```c++
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

3）访问元素

以通过数组名称加索引进行访问

```c++
double salary = balance[9];
```

### 多维数组

1）声明数组

```c++
// type name[size1][size2]...[sizeN];
int threedim[5][10][4]; // 三维 5 . 10 . 4 整型数组
```

2）初始化

```c++
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
// 内部嵌套的括号是可选的，下面的初始化与上面是等同的：
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

3）访问元素

以通过数组名称加索引进行访问

```c++
int val = a[2][3];
```

循环遍历数组

```c++
// 一个带有 5 行 2 列的数组
int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};
// 遍历
for (int i = 0; i < 5; i++)
{
    for (int j = 0; j < 2; j++)
    {
        cout << "a[" << i << "][" << j << "]: ";
        cout << a[i][j] << endl;
    }
}
```

```
a[0][0]: 0
a[0][1]: 0
a[1][0]: 1
a[1][1]: 2
a[2][0]: 2
a[2][1]: 4
a[3][0]: 3
a[3][1]: 6
a[4][0]: 4
a[4][1]: 8
```

### 指向数组的指针

```c++
double runoobAarray[50];
```

**runoobAarray** 是一个指向 &runoobAarray[0] 的指针，即数组 runoobAarray 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **runoobAarray** 的第一个元素的地址：

```c++
double *p;
double runoobAarray[10];

p = runoobAarray;
```

因此，*(runoobAarray + 4) 是一种访问 runoobAarray[4] 数据的合法方式。

第一个元素的地址存储在 p 中，也可以使用 \*p、\*(p+1)、*(p+2) 等来访问数组元素。

**注意：**C++ 中，将 **char \*** 或 **char[]** 传递给 **cout** 进行输出，结果会是整个字符串，如果想要获得字符串的地址（第一个字符的内存地址），可使用以下方法：

- 强制转化为其他指针（非 **char\***）。可以是 **void \*，int \*，float \*， double \*** 等。
- 如果想得到地址，还可可采用 **&** 。
- 指定格式输出。

```c++
#include <iostream>
using namespace std;
 
int main ()
{
   
    char name[] = "Zara Ali";
    // char[],输出整个字符数组的描述（就是字符串）
    cout << name << endl; 
    // char[],输出数组的地址（就是首字符的地址）
    cout << &name << endl; 
    // 由于&name[1]的类型是char*,直接输出会是字符串，需要强转类型才能输出地址
    cout << (void *)&name[1] << endl;
    //print可以指定输出样式，所以没有上面cout的问题
    printf("name:%s  name:%p  &name:%p &name[1]:%p\n",name,name,&name,&name[1]);
    
    cout << "********************" << endl;
    
    int bbb[] = {1,2,3,4};
    // int[],输出整个数组的描述（数组变量的地址代表整个变量的描述）
    cout << bbb << endl;
    // int[],输出数组的地址（就是首元素的地址）
    cout << &bbb << endl;
    // &bbb[1] 输出下标为1的元素的地址（就是输出一个int *的指针变量的值）
    cout << &bbb[1]<< endl;
    
    return 0;
}
```

```
Zara Ali
0x7ffeefbff46f
0x7ffeefbff470
name:Zara Ali  name:0x7ffeefbff46f  &name:0x7ffeefbff46f &name[1]:0x7ffeefbff470
********************
0x7ffeefbff450
0x7ffeefbff450
0x7ffeefbff454
```

### 数组作为函数参数

*可以通过指定不带索引的数组名来传递一个指向数组的指针*。

```c++
/*
	方式 1 形式参数是一个指针
*/
void myFunction(int *param)
{
	...
}

/*
	方式 2 形式参数是一个已定义大小的数组
*/
void myFunction(int param[5])
{
	...
}

/*
	方式 3 形式参数是一个未定义大小的数组
*/
void myFunction(int param[])
{
	...
}
```

```c++
#include <iostream>
using namespace std;
 
// 函数声明
double getAverage(int arr[], int size);
 
int main ()
{
   // 带有 5 个元素的整型数组
   int balance[5] = {1000, 2, 3, 17, 50};
   double avg;
 
   // 传递一个指向数组的指针作为参数
   avg = getAverage( balance, 5 ) ;
 
   // 输出返回值
   cout << "平均值是：" << avg << endl; 
    
   return 0;
}

double gerAverage(int arr[], int size)
{
    int sum = 0;
    double avg;
    
    for (int i = 0; i < size; i++)
    {
        sum += arr[i];
    }
    avg = double(sum) / size;
    
    return avg;
}
```

```
平均值是： 214.4
```

### 数组作为函数返回值

必须声明一个返回指针的函数

```c++
int * myFunction() {
    //. . .
}
```

不能简单地返回指向局部数组的指针，因为当函数结束时，局部数组将被销毁，指向它的指针将变得无效，为了避免以上情况，你可以使用**静态数组**或者**动态分配数组**。

```c++
// 静态 static
int* myFunction()
{
   static int myArray[3] = {1, 2, 3};
   return myArray;
}

// 动态堆区分配 
// 使用 new 运算符来分配一个数组
// 并在函数结束时使用 delete 运算符释放该数组
int* myFunction()
{
   int* myArray = new int[3];
   myArray[0] = 1;
   myArray[1] = 2;
   myArray[2] = 3;
   return myArray;
}

int main()
{
   int* result = myFunction();
   // 使用 result
   delete[] result;
   return 0;
}
```

```c++
#include<iostream>
#include<random>
using namespace std;

// 随机整型数组
int* createRandomArray(int size, int min=0, int max=10);

int main(int argc, char const *argv[])
{
    int *p = createRandomArray(5);
    for (int i = 0; i < 5; i++)
    {
        cout << "p[" << i << "]: " << p[i];
        cout << endl;
    }
    delete[] p;

    return 0;
}

int* createRandomArray(int size, int min, int max)
{
    random_device r1;
    mt19937 gen(r1());
    uniform_int_distribution<> dis(min, max);

    int* arr = new int[size];
    for (int i = 0; i < size; i++)
    {
        arr[i] = dis(gen);
    }

    return arr;
}
```

```
p[0]: 4
p[1]: 2
p[2]: 7
p[3]: 7
p[4]: 6
```

## 14. 字符串

C++ 提供了以下两种类型的字符串表示形式：

- C 风格字符串
- C++ 引入的 string 类类型

![C/C++ 中的字符串表示](https://www.runoob.com/wp-content/uploads/2014/09/c-strings-2020-12-21.png)

C++ 编译器会在初始化数组时，自动把 **\0** 放在字符串的末尾。

```c++
#include <iostream>
 
using namespace std;
 
int main ()
{
   char site[7] = {'R', 'U', 'N', 'O', 'O', 'B'};
 
   cout << "菜鸟: ";
   cout << site << endl;
 
   return 0;
}
```

```
菜鸟教程: RUNOOB
```

|        函数        |                             目的                             |
| :----------------: | :----------------------------------------------------------: |
| **strcpy(s1, s2)** |                 复制字符串 s2 到字符串 s1。                  |
| **strcat(s1, s2)** | 连接字符串 s2 到字符串 s1 的末尾。<br />连接字符串也可以用 **+** 号，例如:<br /> `string str = str1 + str2;` |
|   **strlen(s1)**   |                    返回字符串 s1 的长度。                    |
| **strcmp(s1, s2)** | 如果 s1 和 s2 是相同的，则返回 0；<br />如果 s1<s2 则返回值小于 0；<br />如果 s1>s2 则返回值大于 0。 |
| **strchr(s1, ch)** |  返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。  |
| **strstr(s1, s2)** | 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

```c++
#include <iostream>
#include <cstring>
 
using namespace std;
 
int main ()
{
   char str1[13] = "runoob";
   char str2[13] = "google";
   char str3[13];
   int  len ;
 
   // 复制 str1 到 str3
   strcpy( str3, str1);
   cout << "strcpy( str3, str1) : " << str3 << endl;
 
   // 连接 str1 和 str2
   strcat( str1, str2);
   cout << "strcat( str1, str2): " << str1 << endl;
 
   // 连接后，str1 的总长度
   len = strlen(str1);
   cout << "strlen(str1) : " << len << endl;
 
   return 0;
}
```

```
strcpy( str3, str1) : runoob
strcat( str1, str2): runoobgoogle
strlen(str1) : 12
```

###  String 类

C++ 标准库提供了 **string** 类类型，支持上述所有的操作，另外还增加了其他更多的功能。

[C++的string库用法总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/388823262)

```c++
#include <iostream>
#include <string>
 
using namespace std;
 
int main ()
{
   string str1 = "runoob";
   string str2 = "google";
   string str3;
   int  len ;
 
   // 复制 str1 到 str3
   str3 = str1;
   cout << "str3 : " << str3 << endl;
 
   // 连接 str1 和 str2
   str3 = str1 + str2;
   cout << "str1 + str2 : " << str3 << endl;
 
   // 连接后，str3 的总长度
   len = str3.size();
   cout << "str3.size() :  " << len << endl;
 
   return 0;
}
```

```
str3 : runoob
str1 + str2 : runoobgoogle
str3.size() :  12
```

## 15.指针

一提起指针，就要想到地址。

每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。

```c++
#include <iostream>
 
using namespace std;
 
int main ()
{
   int  var1;
   char var2[10];
 
   cout << "var1 变量的地址： ";
   cout << &var1 << endl;
 
   cout << "var2 变量的地址： ";
   cout << &var2 << endl;
 
   return 0;
}
```

```
var1 变量的地址： 0xbfebd5c0
var2 变量的地址： 0xbfebd5b6
```

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。

```c++
// type *var-name;
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```

所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是**一个代表内存地址的长的十六进制数**(64位 8字节)。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

使用指针时会频繁进行以下几个操作：

- 定义一个指针变量；
- 把变量地址赋值给指针；
- 使用一元运算符 *****访问指针变量中可用地址的值。

```c++
#include <iostream>
 
using namespace std;
 
int main ()
{
   int  var = 20;   // 实际变量的声明
   int  *ip;        // 指针变量的声明
 
   ip = &var;       // 在指针变量中存储 var 的地址
 
   cout << "Value of var variable: ";
   cout << var << endl;
 
   // 输出在指针变量中存储的地址
   cout << "Address stored in ip variable: ";
   cout << ip << endl;
 
   // 访问指针中地址的值
   cout << "Value of *ip variable: ";
   cout << *ip << endl;
 
   return 0;
}
```

```
Value of var variable: 20
Address stored in ip variable: 0xbfc601ac
Value of *ip variable: 20
```

### NULL 指针

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为**空**指针。

```c++
#include <iostream>

using namespace std;

int main ()
{
   int  *ptr = NULL;

   cout << "ptr 的值是 " << ptr ;
 
   return 0;
}
```

```
ptr 的值是 0
```

在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

```c++
// 指针判空
if(ptr)     /* 如果 ptr 非空，则完成 */
if(!ptr)    /* 如果 ptr 为空，则完成 */
```

### 指针算术运算

*可以对指针进行四种算术运算：++、--、+、-。*

- 加法运算：可以对指针进行加法运算。当一个指针p加上一个整数n时，结果是指针p向前移动n个元素的大小。例如，如果p是一个int类型的指针，每个int占4个字节，那么p + 1将指向p所指向的下一个int元素。

  ```c++
  #include <iostream>
   
  using namespace std;
  const int MAX = 3;
   
  int main ()
  {
     int  var[MAX] = {10, 100, 200};
     int  *ptr;
   
     // 指针中的数组地址
     ptr = var;
     for (int i = 0; i < MAX; i++)
     {
        cout << "Address of var[" << i << "] = ";
        cout << ptr << endl;
   
        cout << "Value of var[" << i << "] = ";
        cout << *ptr << endl;
   
        // 移动到下一个位置
        ptr++;
     }
     return 0;
  }
  ```

  ```
  Address of var[0] = 0xbfa088b0
  Value of var[0] = 10
  Address of var[1] = 0xbfa088b4
  Value of var[1] = 100
  Address of var[2] = 0xbfa088b8
  Value of var[2] = 200
  ```

- 减法运算：可以对指针进行减法运算。当一个指针p减去一个整数n时，结果是指针p向后移动n个元素的大小。例如，如果p是一个int类型的指针，每个int占4个字节，那么p - 1将指向p所指向的前一个int元素。

  ```c++
  #include <iostream>
   
  using namespace std;
  const int MAX = 3;
   
  int main ()
  {
     int  var[MAX] = {10, 100, 200};
     int  *ptr;
   
     // 指针中最后一个元素的地址
     ptr = &var[MAX-1];
     for (int i = MAX; i > 0; i--)
     {
        cout << "Address of var[" << i << "] = ";
        cout << ptr << endl;
   
        cout << "Value of var[" << i << "] = ";
        cout << *ptr << endl;
   
        // 移动到下一个位置
        ptr--;
     }
     return 0;
  }
  ```

  ```
  Address of var[3] = 0xbfdb70f8
  Value of var[3] = 200
  Address of var[2] = 0xbfdb70f4
  Value of var[2] = 100
  Address of var[1] = 0xbfdb70f0
  Value of var[1] = 10
  ```

- 指针与指针之间的减法运算：可以计算两个指针之间的距离。当从一个指针p减去另一个指针q时，结果是两个指针之间的元素个数。例如，如果p和q是两个int类型的指针，每个int占4个字节，那么p - q将得到两个指针之间的元素个数。

- 指针与整数之间的比较运算：可以将指针与整数进行比较运算。可以使用关系运算符（如<、>、<=、>=）对指针和整数进行比较。这种比较通常用于判断指针是否指向某个有效的内存位置。

  ```c++
  #include <iostream>
   
  using namespace std;
  const int MAX = 3;
   
  int main ()
  {
     int  var[MAX] = {10, 100, 200};
     int  *ptr;
   
     // 指针中第一个元素的地址
     ptr = var;
     int i = 0;
     while ( ptr <= &var[MAX - 1] )
     {
        cout << "Address of var[" << i << "] = ";
        cout << ptr << endl;
   
        cout << "Value of var[" << i << "] = ";
        cout << *ptr << endl;
   
        // 指向上一个位置
        ptr++;
        i++;
     }
     return 0;
  }
  ```

  ```
  Address of var[0] = 0xbfce42d0
  Value of var[0] = 10
  Address of var[1] = 0xbfce42d4
  Value of var[1] = 100
  Address of var[2] = 0xbfce42d8
  Value of var[2] = 200
  ```

### 指针 VS 数组

指针和数组在很多情况下是可以互换的。

```c++
#include <iostream>
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
   int  *ptr;
 
   // 指针中的数组地址
   ptr = var;
   for (int i = 0; i < MAX; i++)
   {
      cout << "var[" << i << "]的内存地址为 ";
      cout << ptr << endl;
 
      cout << "var[" << i << "] 的值为 ";
      cout << *ptr << endl;
 
      // 移动到下一个位置
      ptr++;
   }
   return 0;
}
```

```
var[0]的内存地址为 0x7fff59707adc
var[0] 的值为 10
var[1]的内存地址为 0x7fff59707ae0
var[1] 的值为 100
var[2]的内存地址为 0x7fff59707ae4
var[2] 的值为 200
```

然而，指针和数组并不是完全互换的。

```c++
#include <iostream>
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
 
   for (int i = 0; i < MAX; i++)
   {
      *var = i;    // 这是正确的语法
      var++;       // 这是不正确的
   }
   return 0;
}
```

把指针运算符 * 应用到 var 上是完全可以的，但修改 var 的值是非法的。

由于一个数组名对应一个指针常量，只要不改变数组的值，仍然可以用指针形式的表达式。例如，下面是一个有效的语句，把 var[2] 赋值为 500：

```c++
*(var + 2) = 500;
```

### 指针数组

用数组存储指向 int 或 char 或其他数据类型的指针。

```c++
int *ptr[MAX];
```

把 **ptr** 声明为一个数组，由 MAX 个整数指针组成。

ptr 中的每个元素，都是一个指向 int 值的指针；将其保存整型数组的元素地址。

```c++
#include <iostream>
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
   int *ptr[MAX];
 
   for (int i = 0; i < MAX; i++)
   {
      ptr[i] = &var[i]; // 赋值为整数的地址
   }
   for (int i = 0; i < MAX; i++)
   {
      cout << "Value of var[" << i << "] = ";
      cout << *ptr[i] << endl;
   }
   return 0;
}
```

```
Value of var[0] = 10
Value of var[1] = 100
Value of var[2] = 200
```

也可以用一个指向字符的指针数组来存储一个字符串列表

```c++
#include <iostream>
 
using namespace std;
const int MAX = 4;
 
int main ()
{
 const char *names[MAX] = {
                   "Zara Ali",
                   "Hina Ali",
                   "Nuha Ali",
                   "Sara Ali",
   };
 
   for (int i = 0; i < MAX; i++)
   {
      cout << "Value of names[" << i << "] = ";
      cout << names[i] << endl;
   }
   return 0;
}
```

```
Value of names[0] = Zara Ali
Value of names[1] = Hina Ali
Value of names[2] = Nuha Ali
Value of names[3] = Sara Ali
```

### 指向指针的指针（多级间接寻址）

![C++ 中指向指针的指针](https://www.runoob.com/wp-content/uploads/2014/09/pointer_to_pointer.jpg)

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。

```c++
int **var;
```

```c++
#include <iostream>
 
using namespace std;
 
int main ()
{
    int  var;
    int  *ptr;
    int  **pptr;
 
    var = 3000;
 
    // 获取 var 的地址
    ptr = &var;
 
    // 使用运算符 & 获取 ptr 的地址
    pptr = &ptr;
 
    // 使用 pptr 获取值
    cout << "var 值为 :" << var << endl;
    cout << "*ptr 值为:" << *ptr << endl;
    cout << "**pptr 值为:" << **pptr << endl;
 
    return 0;
}
```

```
var 值为 :3000
*ptr 值为:3000
**pptr 值为:3000
```

### 传递指针给函数

```c++
#include <iostream>
#include <ctime>
 
using namespace std;
 
// 在写函数时应习惯性的先声明函数，然后在定义函数
void getSeconds(unsigned long *par);
 
int main ()
{
   unsigned long sec;
 
 
   getSeconds( &sec );
 
   // 输出实际值
   cout << "Number of seconds :" << sec << endl;
 
   return 0;
}
 
void getSeconds(unsigned long *par)
{
   // 获取当前的秒数
   *par = time( NULL );
   return;
}
```

```
Number of seconds :1294450468
```

### 从函数返回指针

与数组原理相同， static 或 new。

## 16.引用

引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。

一方修改，等于自身修改。

### 1）引用 vs 指针

它们之间有三个主要的不同：

- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象；指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化；指针可以在任何时间被初始化。

### 2）创建引用

```c++
#include <iostream>
 
using namespace std;
 
int main ()
{
   // 声明简单的变量
   int    i;
   double d;
 
   // 声明引用变量
   int&    r = i;
   double& s = d;
   
   i = 5;
   cout << "Value of i : " << i << endl;
   cout << "Value of i reference : " << r  << endl;
 
   d = 11.7;
   cout << "Value of d : " << d << endl;
   cout << "Value of d reference : " << s  << endl;
   
   return 0;
}
```

```
Value of i : 5
Value of i reference : 5
Value of d : 11.7
Value of d reference : 11.7
```

### 3）引用作为参数

引用作为参数传给函数，这比传一般的参数更安全。

```c++
#include <iostream>
using namespace std;
 
// 函数声明
void swap(int& x, int& y);
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
 
   cout << "交换前，a 的值：" << a << endl;
   cout << "交换前，b 的值：" << b << endl;
 
   /* 调用函数来交换值 */
   swap(a, b);
 
   cout << "交换后，a 的值：" << a << endl;
   cout << "交换后，b 的值：" << b << endl;
 
   return 0;
}
 
// 函数定义
void swap(int& x, int& y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
```

```
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 200
交换后，b 的值： 100
```

### 4）引用作为返回值

```c++
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues(int i) {  
   double& ref = vals[i];    
   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]
}
 
// 要调用上面定义函数的主函数
int main ()
{
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
```

```
改变前的值
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
改变后的值
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50
```

当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。

```c++
int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```

## 17.日期 & 时间

为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。

有四个与时间相关的类型：**clock_t、time_t、size_t** 和 **tm**。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。

结构类型 **tm** 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：

```c++
struct tm {
  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61
  int tm_min;   // 分，范围从 0 到 59
  int tm_hour;  // 小时，范围从 0 到 23
  int tm_mday;  // 一月中的第几天，范围从 1 到 31
  int tm_mon;   // 月，范围从 0 到 11
  int tm_year;  // 自 1900 年起的年数
  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起
  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起
  int tm_isdst; // 夏令时
};
```

|                             函数                             | 描述                                                         |
| :----------------------------------------------------------: | :----------------------------------------------------------- |
| [**time_t time(time_t \*time);**](https://www.runoob.com/cplusplus/c-function-time.html) | 返回系统的当前日历时间，如果系统没有时间，则返回 -1。自 1970 年 1 月 1 日以来经过的秒数。 |
| [**char \*ctime(const time_t \*time);**](https://www.runoob.com/cplusplus/c-function-ctime.html) | 该返回一个表示当地时间的字符串指针，字符串形式 *day month year hours:minutes:seconds year\n\0*。 |
| [**struct tm \*localtime(const time_t \*time);**](https://www.runoob.com/cplusplus/c-function-localtime.html) | 该函数返回一个指向表示本地时间的 **tm** 结构的指针。         |
| [**clock_t clock(void);**](https://www.runoob.com/cplusplus/c-function-clock.html) | 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。 |
| [**char \* asctime ( const struct tm \* time );**](https://www.runoob.com/cplusplus/c-function-asctime.html) | 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。 |
| [**struct tm \*gmtime(const time_t \*time);**](https://www.runoob.com/cplusplus/c-function-gmtime.html) | 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 |
| [time_t mktime(struct tm \*time)](https://www.runoob.com/cplusplus/c-function-mktime.html) | 该函数返回日历时间，相当于 time 所指向结构中存储的时间。     |
| [**double difftime ( time_t time2, time_t time1 );**](https://www.runoob.com/cplusplus/c-function-difftime.html) | 该函数返回 time1 和 time2 之间相差的秒数。                   |
| [**size_t strftime();**](https://www.runoob.com/cplusplus/c-function-strftime.html) | 该函数可用于格式化日期和时间为指定的格式。                   |

## 18.基本的输入输出

*C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做**输入操作**。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做**输出操作***。

|   头文件   | 函数和描述                                                   |
| :--------: | :----------------------------------------------------------- |
| <iostream> | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |
| <iomanip>  | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |
| <fstream>  | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 |

### 标准输出流（cout）

```c++
#include <iostream>
 
using namespace std;
 
int main( )
{
   char str[] = "Hello C++";
 
   cout << "Value of str is : " << str << endl;
}
```

```
Value of str is : Hello C++
```

###  标准输入流（cin）

```c++
#include <iostream>
 
using namespace std;
 
int main( )
{
   char name[50];
 
   cout << "请输入您的名称： ";
   cin >> name;
   cout << "您的名称是： " << name << endl;
 
}
```

```
请输入您的名称： cplusplus
您的名称是： cplusplus
```

### 标准错误流（cerr）

**cerr** 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。

```c++
#include <iostream>
 
using namespace std;
 
int main( )
{
   char str[] = "Unable to read....";
 
   cerr << "Error message : " << str << endl;
}
```

```
Error message : Unable to read....
```

### 标准日志流（clog）

 **clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。

```c++
#include <iostream>
 
using namespace std;
 
int main( )
{
   char str[] = "Unable to read....";
 
   clog << "Error message : " << str << endl;
}
```

```
Error message : Unable to read....
```

**良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。**

## 19.结构

***结构***是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

C++ 结构可以有函数，C 结构不可以有函数。

类与结构体在 C++ 中只有两点区别，除此这外无任何区别。

- （1）class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。
- （2）从 class 继承默认是 private 继承，而从 struct 继承默认是 public 继承。
- （3）class 可以定义模板，而 struct 不可以。

### 1）定义结构

```c++
/*
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
*/

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;
```

### 2）访问结构成员

使用**成员访问运算符（.）**

```c++
#include <iostream>
#include <cstring>
 
using namespace std;
 
// 声明一个结构体类型 Books 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   Books Book1;        // 定义结构体类型 Books 的变量 Book1
   Books Book2;        // 定义结构体类型 Books 的变量 Book2
 
   // Book1 详述
   strcpy( Book1.title, "C++ 教程");
   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "编程语言");
   Book1.book_id = 12345;
 
   // Book2 详述
   strcpy( Book2.title, "CSS 教程");
   strcpy( Book2.author, "Runoob");
   strcpy( Book2.subject, "前端技术");
   Book2.book_id = 12346;
 
   // 输出 Book1 信息
   cout << "第一本书标题 : " << Book1.title <<endl;
   cout << "第一本书作者 : " << Book1.author <<endl;
   cout << "第一本书类目 : " << Book1.subject <<endl;
   cout << "第一本书 ID : " << Book1.book_id <<endl;
 
   // 输出 Book2 信息
   cout << "第二本书标题 : " << Book2.title <<endl;
   cout << "第二本书作者 : " << Book2.author <<endl;
   cout << "第二本书类目 : " << Book2.subject <<endl;
   cout << "第二本书 ID : " << Book2.book_id <<endl;
 
   return 0;
}
```

```
第一本书标题 : C++ 教程
第一本书作者 : Runoob
第一本书类目 : 编程语言
第一本书 ID : 12345
第二本书标题 : CSS 教程
第二本书作者 : Runoob
第二本书类目 : 前端技术
第二本书 ID : 12346
```

### 3）结构作为函数参数

```c++
#include <iostream>
#include <cstring>
 
using namespace std;
void printBook( struct Books book );
 
// 声明一个结构体类型 Books 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   Books Book1;        // 定义结构体类型 Books 的变量 Book1
   Books Book2;        // 定义结构体类型 Books 的变量 Book2
 
    // Book1 详述
   strcpy( Book1.title, "C++ 教程");
   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "编程语言");
   Book1.book_id = 12345;
 
   // Book2 详述
   strcpy( Book2.title, "CSS 教程");
   strcpy( Book2.author, "Runoob");
   strcpy( Book2.subject, "前端技术");
   Book2.book_id = 12346;
 
   // 输出 Book1 信息
   printBook( Book1 );
 
   // 输出 Book2 信息
   printBook( Book2 );
 
   return 0;
}
void printBook( struct Books book )
{
   cout << "书标题 : " << book.title <<endl;
   cout << "书作者 : " << book.author <<endl;
   cout << "书类目 : " << book.subject <<endl;
   cout << "书 ID : " << book.book_id <<endl;
}
```

```
书标题 : C++ 教程
书作者 : Runoob
书类目 : 编程语言
书 ID : 12345
书标题 : CSS 教程
书作者 : Runoob
书类目 : 前端技术
书 ID : 12346
```

### 4）指向结构的指针

```c++
struct Books *struct_pointer;
// 把 & 运算符放在结构名称的前面
struct_pointer = &Book1;
// 使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符
struct_pointer->title;
```

```c++
#include <iostream>
#include <cstring>
 
using namespace std;
void printBook( struct Books *book );
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   Books Book1;        // 定义结构体类型 Books 的变量 Book1
   Books Book2;        // 定义结构体类型 Books 的变量 Book2
 
    // Book1 详述
   strcpy( Book1.title, "C++ 教程");
   strcpy( Book1.author, "Runoob"); 
   strcpy( Book1.subject, "编程语言");
   Book1.book_id = 12345;
 
   // Book2 详述
   strcpy( Book2.title, "CSS 教程");
   strcpy( Book2.author, "Runoob");
   strcpy( Book2.subject, "前端技术");
   Book2.book_id = 12346;
 
   // 通过传 Book1 的地址来输出 Book1 信息
   printBook( &Book1 );
 
   // 通过传 Book2 的地址来输出 Book2 信息
   printBook( &Book2 );
 
   return 0;
}
// 该函数以结构指针作为参数
void printBook( struct Books *book )
{
   cout << "书标题  : " << book->title <<endl;
   cout << "书作者 : " << book->author <<endl;
   cout << "书类目 : " << book->subject <<endl;
   cout << "书 ID : " << book->book_id <<endl;
}
```

```
书标题  : C++ 教程
书作者 : Runoob
书类目 : 编程语言
书 ID : 12345
书标题  : CSS 教程
书作者 : Runoob
书类目 : 前端技术
书 ID : 12346
```

### 5）typedef 关键字

可以为数据类型取别名

```c++
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
}Books;
// 直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字
Books Book1, Book2;

typedef long int *pint32;
// x, y 和 z 都是指向长整型 long int 的指针
pint32 x, y, z;
```

# 参考资料

[C++ 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cplusplus/cpp-tutorial.html)

[用C++的random库生成更好的随机数_导入random库的方法c++-CSDN博客](https://blog.csdn.net/henry_23/article/details/113623544)

[ | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/standard-library/random?view=msvc-170)

[C++的string库用法总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/388823262)
